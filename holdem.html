<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>텍사스 홀덤 승률 계산기</title>
  <style>
    :root {
      --bg: #0a0c10;
      --panel: #11151c;
      --panel-2: #151b24;
      --text: #f3f0e8;
      --muted: #b7b0a3;
      --accent: #d7b468;
      --accent-2: #f3d290;
      --gold: #f5d07a;
      --danger: #e06b6b;
      --card: #0f141b;
      --card-hi: #1a2230;
      --card-picked: #2c3b2f;
      --card-disabled: #0e141a;
      --border: rgba(220, 198, 140, 0.18);
      --shadow: 0 24px 60px rgba(0, 0, 0, 0.55);
      --glow: 0 0 36px rgba(215, 180, 104, 0.2);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Playfair Display", "Noto Serif KR", "Pretendard", "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      background:
        radial-gradient(700px 400px at 15% -10%, rgba(215, 180, 104, 0.15), transparent),
        radial-gradient(900px 600px at 85% -10%, rgba(255, 240, 200, 0.08), transparent),
        linear-gradient(180deg, #0a0c10 0%, #0d1016 100%);
      color: var(--text);
    }
    .wrap {
      width: min(1200px, 100% - 32px);
      margin: 0 auto;
      padding: 20px 0;
      display: grid;
      gap: 16px;
    }
    h1 {
      margin: 0 0 8px 0;
      font-size: 26px;
      letter-spacing: 0.4px;
    }
    .disclaimer {
      background: linear-gradient(120deg, rgba(45, 32, 24, 0.9), rgba(55, 36, 26, 0.9));
      color: #ffe8d6;
      border: 1px solid rgba(245, 208, 122, 0.25);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      font-size: 14px;
    }
    .grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 16px;
    }
    .panel {
      background: linear-gradient(180deg, rgba(17, 21, 28, 0.95), rgba(15, 18, 24, 0.95));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    .panel h2 {
      margin: 0 0 8px 0;
      font-size: 16px;
      color: var(--muted);
    }
    .panel h2 strong { color: var(--text); font-weight: 800; }
    .card-grid {
      display: grid;
      gap: 8px;
    }
    .suit-row {
      display: grid;
      grid-template-columns: repeat(13, minmax(36px, 1fr));
      gap: 6px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 4px;
      text-align: center;
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      transition: transform 80ms ease, background 120ms ease, border 120ms ease, opacity 120ms ease;
    }
    .card:hover { transform: translateY(-1px); background: var(--card-hi); box-shadow: var(--glow); }
    .card.picked {
      background: var(--card-picked);
      border-color: #3f8f69;
    }
    .card.disabled {
      background: var(--card-disabled);
      border-color: #222c33;
      opacity: 0.4;
      cursor: not-allowed;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row label { color: var(--muted); font-size: 13px; }
    select, input, button {
      background: var(--panel-2);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 14px;
    }
    button {
      cursor: pointer;
      font-weight: 700;
    }
    button.primary {
      background: linear-gradient(120deg, var(--accent), var(--accent-2));
      color: #2a1c05;
      border-color: rgba(215, 180, 104, 0.6);
      box-shadow: var(--glow);
    }
    button.danger {
      background: #3b1e1e;
      color: #ffe9e9;
      border-color: #6d3b3b;
    }
    .pill {
      display: inline-block;
      background: var(--panel-2);
      border: 1px solid var(--border);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: #15222a;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: transform 80ms ease, background 120ms ease;
    }
    .chip:hover { transform: translateY(-1px); background: #1a2b35; }
    .chip .x {
      color: #ffb3b3;
      font-weight: 700;
      font-size: 12px;
    }
    .cards-inline {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .mini-card {
      background: #1a2630;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      font-weight: 800;
      min-width: 36px;
      text-align: center;
      box-shadow: var(--shadow);
      transform: translateY(0);
      opacity: 0;
      animation: pop 240ms ease forwards;
    }
    .red { color: #e35b5b; }
    @keyframes pop {
      from { transform: translateY(6px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .subtle {
      color: var(--muted);
      font-size: 12px;
    }
    .result {
      display: grid;
      gap: 8px;
      font-size: 14px;
    }
    .result strong { font-size: 16px; }
    .progress {
      width: 100%;
      height: 10px;
      background: #12181c;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }
    .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2fbf89, #88f0c9);
      transition: width 80ms ease;
    }
    .board-info {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }
    .threat {
      background: #111a21;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      display: grid;
      gap: 6px;
    }
    .threat-row {
      display: grid;
      grid-template-columns: 92px 1fr 54px;
      gap: 8px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
    }
    .threat-bar {
      height: 8px;
      background: #0f151a;
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }
    .threat-bar span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, #ffb88a, #ff8a8a);
      width: 0%;
    }
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      font-size: 13px;
      color: var(--muted);
      cursor: pointer;
    }
    .section {
      display: grid;
      gap: 10px;
    }
    .legal {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }
    .cards-inline.small .mini-card {
      min-width: 28px;
      padding: 4px 6px;
      font-size: 12px;
    }
    .blackjack {
      display: grid;
      gap: 10px;
    }
    .blackjack .hand {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .blackjack .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .blackjack .status {
      font-size: 13px;
      color: var(--muted);
    }
    .split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      .split { grid-template-columns: 1fr; }
    }
    .footer {
      margin-top: 8px;
      font-size: 13px;
      color: #ffdede;
      background: #2a2020;
      border: 1px solid #4a2d2d;
      padding: 8px 10px;
      border-radius: 8px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div id="app"></div>
  <script>
    document.getElementById('app').innerHTML = `
  <div class="wrap">
    <div class="topbar">
      <div>
        <h1>텍사스 홀덤 승률 계산기</h1>
        <div class="disclaimer">본 서비스는 학습/게임 분석용이며, 도박/금전 조언이 아닙니다.</div>
      </div>
      <div class="row">
        <a class="pill" href="index.html">메인</a>
        <a class="pill" href="holdem.html">승률 계산기</a>
        <a class="pill" href="minigames.html">미니게임</a>
        <a class="pill" href="leaderboard.html">레더보드</a>
        <a class="pill" href="policy.html">정책/고지</a>
        
      </div>
    </div>

    <div class="grid">
      <section class="panel">
        <h2><strong>카드 선택</strong></h2>
        <div class="card-grid" id="cardGrid"></div>
      </section>

      <section class="panel">
        <h2><strong>현재 선택</strong></h2>
        <div class="row">
          <label>내 핸드:</label>
          <div id="myHand" class="cards-inline"></div>
        </div>
        <div class="row">
          <label>보드:</label>
          <div id="board" class="cards-inline"></div>
        </div>
        <div class="row">
          <label for="opponents">상대 수</label>
          <select id="opponents">
            <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
          </select>
          <label for="trials">Trials</label>
          <input id="trials" type="number" min="1000" max="200000" step="1000" value="30000" />
        </div>
        <div class="row">
          <button class="primary" id="runBtn">시뮬레이션 실행</button>
          <button class="danger" id="resetBtn">선택 초기화</button>
        </div>
        <div class="row">
          <span class="pill" id="stageInfo">단계: 프리플랍</span>
        </div>
      </section>
    </div>

    <section class="panel">
      <h2><strong>결과</strong></h2>
      <div class="result">
        <div class="split">
          <div>Win: <strong id="winPct">-</strong></div>
          <div>Tie: <strong id="tiePct">-</strong></div>
          <div>Lose: <strong id="losePct">-</strong></div>
          <div>내 족보: <strong id="myRank">-</strong></div>
        </div>
        <div class="subtle">현재 최고 5장 조합</div>
        <div class="cards-inline" id="bestFive">-</div>
        <div class="subtle">키커 상세</div>
        <div class="board-info" id="kickerInfo">-</div>
        <div class="board-info" id="uncertainty">Trials가 많을수록 결과가 안정적입니다.</div>
        <div class="progress"><div class="bar" id="bar"></div></div>
        <div class="board-info" id="progressText">대기 중</div>
        <div class="board-info" id="textureInfo">보드 텍스처: -</div>
        <div class="subtle">내 핸드를 이긴 상대 족보(시뮬레이션 기반)</div>
        <div class="threat" id="threatBox">-</div>
      </div>
    </section>

    <section class="panel section">
      <h2><strong>게임 규칙</strong></h2>
      <div class="board-info">
        내 핸드 2장과 보드 0~5장을 선택해 시뮬레이션을 진행합니다.
        상대 수(1~5명)와 Trials 수에 따라 무작위 분포가 반복됩니다.
      </div>
      <div class="board-info">
        각 Trial마다 남은 덱에서 상대 핸드와 보드를 완성하고,
        7장 중 최적 5장 조합으로 족보를 비교합니다.
      </div>
      <div class="board-info">
        본 계산은 학습용 확률 추정이며, 결과는 표본 수에 따라 변동될 수 있습니다.
      </div>
    </section>

    <section class="panel section">
      <h2><strong>가이드</strong></h2>
      <div class="board-info">
        이 도구는 확률 추정과 보드 텍스처 이해를 돕기 위한 참고용입니다.
        승률은 랜덤 시뮬레이션 기반의 추정치이므로 Trials가 적으면 변동이 커질 수 있습니다.
      </div>
      <div class="board-info">
        텍스처 예시: 플러시 드로우/스트레이트 드로우가 많을수록 변동성이 커질 수 있습니다.
        페어/트립 보드는 높은 족보가 등장할 가능성을 높입니다.
      </div>
    </section>

    <section class="panel section">
      <h2><strong>학습 포인트</strong></h2>
      <div class="board-info">
        같은 핸드라도 보드 진행에 따라 확률이 크게 달라집니다.
      </div>
      <div class="board-info">
        보드 텍스처는 변동성을 키우는 핵심 요인입니다.
      </div>
      <div class="board-info">
        결과는 표본 수와 무작위성에 의해 변동할 수 있습니다.
      </div>
    </section>

    <section class="panel section">
      <h2><strong>사이트 소개</strong></h2>
      <div class="board-info">
        본 페이지는 텍사스 홀덤의 확률과 족보를 이해하기 위한 학습 자료입니다.
        실전 행동을 지시하지 않으며, 결과는 참고용입니다.
      </div>
    </section>


    <section class="panel section">
      <h2><strong>정책 및 안내</strong></h2>
      <div class="legal">
        <div><strong>이용약관(요약)</strong>: 본 서비스는 정보 제공 및 학습 목적이며, 결과는 보장되지 않습니다.</div>
        <div><strong>개인정보 처리방침(요약)</strong>: 본 페이지는 로컬에서 동작하며 별도의 서버 전송이 없습니다.</div>
        <div><strong>문의</strong>: yoonbyeo@gmail.com</div>
      </div>
    </section>

    <div class="footer">본 서비스는 학습/게임 분석용이며, 도박/금전 조언이 아닙니다.</div>
  </div>
    `;
  </script>
<script>
    // ===== 카드/덱 유틸 =====
    const SUITS = ["S", "H", "D", "C"]; // Spades, Hearts, Diamonds, Clubs
    const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
    const RANK_VALUE = Object.fromEntries(RANKS.map((r, i) => [r, i + 2]));

    function makeDeck() {
      const deck = [];
      for (const s of SUITS) for (const r of RANKS) deck.push(r + s);
      return deck;
    }

    function cardText(card) {
      const r = card[0], s = card[1];
      const suitSymbol = { S: "♠", H: "♥", D: "♦", C: "♣" }[s];
      return r + suitSymbol;
    }
    function cardHTML(card) {
      const s = card[1];
      const red = (s === "H" || s === "D") ? "red" : "";
      return `<span class="${red}">${cardText(card)}</span>`;
    }

    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // ===== 5장 족보 평가 =====
    // 반환 값: { rank: number, tiebreak: number[] }
    // rank: 8(스트레이트플러시) 7(포카드) 6(풀하우스) 5(플러시) 4(스트레이트) 3(트리플) 2(투페어) 1(원페어) 0(하이카드)
    function eval5(cards) {
      const ranks = cards.map(c => RANK_VALUE[c[0]]).sort((a,b)=>b-a);
      const suits = cards.map(c => c[1]);
      const isFlush = suits.every(s => s === suits[0]);

      // 스트레이트 체크 (A2345 포함)
      let unique = [...new Set(ranks)];
      let isStraight = false;
      let straightHigh = 0;
      if (unique.length === 5) {
        if (unique[0] - unique[4] === 4) {
          isStraight = true;
          straightHigh = unique[0];
        } else if (unique[0] === 14 && unique[1] === 5 && unique[4] === 2) {
          isStraight = true;
          straightHigh = 5; // A2345
        }
      }

      // 랭크 카운트
      const counts = {};
      for (const r of ranks) counts[r] = (counts[r] || 0) + 1;
      const countPairs = Object.entries(counts)
        .map(([r,c]) => ({ r: Number(r), c }))
        .sort((a,b) => b.c - a.c || b.r - a.r);

      if (isStraight && isFlush) {
        return { rank: 8, tiebreak: [straightHigh] };
      }
      if (countPairs[0].c === 4) {
        const four = countPairs[0].r;
        const kicker = countPairs[1].r;
        return { rank: 7, tiebreak: [four, kicker] };
      }
      if (countPairs[0].c === 3 && countPairs[1].c === 2) {
        return { rank: 6, tiebreak: [countPairs[0].r, countPairs[1].r] };
      }
      if (isFlush) {
        return { rank: 5, tiebreak: ranks };
      }
      if (isStraight) {
        return { rank: 4, tiebreak: [straightHigh] };
      }
      if (countPairs[0].c === 3) {
        const trips = countPairs[0].r;
        const kickers = countPairs.slice(1).map(x => x.r).sort((a,b)=>b-a);
        return { rank: 3, tiebreak: [trips, ...kickers] };
      }
      if (countPairs[0].c === 2 && countPairs[1].c === 2) {
        const highPair = Math.max(countPairs[0].r, countPairs[1].r);
        const lowPair = Math.min(countPairs[0].r, countPairs[1].r);
        const kicker = countPairs[2].r;
        return { rank: 2, tiebreak: [highPair, lowPair, kicker] };
      }
      if (countPairs[0].c === 2) {
        const pair = countPairs[0].r;
        const kickers = countPairs.slice(1).map(x => x.r).sort((a,b)=>b-a);
        return { rank: 1, tiebreak: [pair, ...kickers] };
      }
      return { rank: 0, tiebreak: ranks };
    }

    function compareHands(a, b) {
      if (a.rank !== b.rank) return a.rank - b.rank;
      for (let i = 0; i < Math.max(a.tiebreak.length, b.tiebreak.length); i++) {
        const diff = (a.tiebreak[i] || 0) - (b.tiebreak[i] || 0);
        if (diff !== 0) return diff;
      }
      return 0;
    }

    // 7장 중 5장 조합 모두 평가
    function eval7(cards) {
      let best = null;
      for (let i = 0; i < 7; i++) for (let j = i+1; j < 7; j++)
      for (let k = j+1; k < 7; k++) for (let l = k+1; l < 7; l++)
      for (let m = l+1; m < 7; m++) {
        const hand = eval5([cards[i], cards[j], cards[k], cards[l], cards[m]]);
        if (!best || compareHands(hand, best) > 0) best = hand;
      }
      return best;
    }

    // ===== sanity tests =====
    function sanityTests() {
      const tests = [];
      const t1 = eval5(["A♠","K♠","Q♠","J♠","T♠"].map(normalizeCard));
      tests.push(t1.rank === 8 && t1.tiebreak[0] === 14);
      const t2 = eval5(["5♦","5♣","5♥","K♠","K♦"].map(normalizeCard));
      tests.push(t2.rank === 6);
      const t3 = eval5(["A♠","2♦","3♥","4♣","5♠"].map(normalizeCard));
      tests.push(t3.rank === 4 && t3.tiebreak[0] === 5);
      const t4 = eval5(["2♠","2♦","2♥","9♣","A♦"].map(normalizeCard));
      const t5 = eval5(["K♠","K♦","Q♥","J♣","9♦"].map(normalizeCard));
      tests.push(compareHands(t4, t5) > 0);
      const ok = tests.every(Boolean);
      console.log(ok ? "SANITY PASS" : "SANITY FAIL", tests);
    }

    function normalizeCard(txt) {
      const r = txt[0];
      const s = txt[1];
      const map = { "♠":"S", "♥":"H", "♦":"D", "♣":"C" };
      return r + map[s];
    }

    // ===== UI 상태 =====
    const state = {
      myHand: [],
      board: [],
      running: false,
    };

    const cardGrid = document.getElementById("cardGrid");
    const myHandEl = document.getElementById("myHand");
    const boardEl = document.getElementById("board");
    const stageInfo = document.getElementById("stageInfo");
    const winPctEl = document.getElementById("winPct");
    const tiePctEl = document.getElementById("tiePct");
    const losePctEl = document.getElementById("losePct");
    const myRankEl = document.getElementById("myRank");
    const bestFiveEl = document.getElementById("bestFive");
    const kickerInfoEl = document.getElementById("kickerInfo");
    const progressText = document.getElementById("progressText");
    const bar = document.getElementById("bar");
    const textureInfo = document.getElementById("textureInfo");
    const threatBox = document.getElementById("threatBox");
    const trialsEl = document.getElementById("trials");
    const opponentsEl = document.getElementById("opponents");
    const runBtn = document.getElementById("runBtn");
    const resetBtn = document.getElementById("resetBtn");

    const allCards = makeDeck();

    function renderCards() {
      cardGrid.innerHTML = "";
      const suitOrder = ["S","H","D","C"];
      for (const s of suitOrder) {
        const row = document.createElement("div");
        row.className = "suit-row";
        for (const r of RANKS) {
          const c = r + s;
          const btn = document.createElement("div");
          btn.className = "card";
          btn.innerHTML = cardHTML(c);
          btn.dataset.card = c;
          btn.onclick = () => onPickCard(c);
          row.appendChild(btn);
        }
        cardGrid.appendChild(row);
      }
      syncCards();
    }

    function syncCards() {
      const picked = new Set([...state.myHand, ...state.board]);
      [...cardGrid.children].forEach(el => {
        const c = el.dataset.card;
        el.classList.toggle("picked", picked.has(c));
        el.classList.toggle("disabled", picked.has(c));
      });
      renderSelected(myHandEl, state.myHand, "내 핸드 없음");
      renderSelected(boardEl, state.board, "보드 없음");
      stageInfo.textContent = stageName();
      textureInfo.textContent = "보드 텍스처: " + analyzeTexture(state.board);
      updateMyHandInfo();
    }

    function stageName() {
      if (state.board.length === 0) return "단계: 프리플랍";
      if (state.board.length === 3) return "단계: 플랍";
      if (state.board.length === 4) return "단계: 턴";
      if (state.board.length === 5) return "단계: 리버";
      return "단계: 진행 중";
    }

    function onPickCard(card) {
      if (state.running) return;
      const picked = new Set([...state.myHand, ...state.board]);
      if (picked.has(card)) return;
      if (state.myHand.length < 2) {
        state.myHand.push(card);
      } else if (state.board.length < 5) {
        state.board.push(card);
      }
      syncCards();
    }

    function resetAll() {
      if (state.running) return;
      state.myHand = [];
      state.board = [];
      winPctEl.textContent = "-";
      tiePctEl.textContent = "-";
      losePctEl.textContent = "-";
      myRankEl.textContent = "-";
      bestFiveEl.textContent = "-";
      kickerInfoEl.textContent = "-";
      threatBox.textContent = "-";
      progressText.textContent = "대기 중";
      bar.style.width = "0%";
      syncCards();
    }

    resetBtn.onclick = resetAll;

    function validateInputs() {
      if (state.myHand.length !== 2) {
        alert("내 핸드 2장을 선택해주세요.");
        return false;
      }
      if (![0,3,4,5].includes(state.board.length)) {
        alert("보드는 0장 또는 3/4/5장만 허용됩니다.");
        return false;
      }
      let t = Number(trialsEl.value) || 0;
      if (t < 1000) t = 1000;
      if (t > 200000) t = 200000;
      trialsEl.value = t;
      return true;
    }

    function analyzeTexture(board) {
      if (board.length === 0) return "보드 미선택";
      const suits = board.map(c => c[1]);
      const ranks = board.map(c => RANK_VALUE[c[0]]);
      const suitCounts = suits.reduce((m,s)=> (m[s]=(m[s]||0)+1, m), {});
      const rankCounts = ranks.reduce((m,r)=> (m[r]=(m[r]||0)+1, m), {});

      const flushDraw = Object.values(suitCounts).some(c => c >= 3);
      const pairOnBoard = Object.values(rankCounts).some(c => c >= 2);
      const tripsOnBoard = Object.values(rankCounts).some(c => c >= 3);
      const straightDraw = hasStraightDraw(ranks);

      const labels = [];
      if (flushDraw) labels.push("플러시 드로우 가능");
      if (straightDraw) labels.push("스트레이트 드로우 가능");
      if (tripsOnBoard) labels.push("트립 보드");
      else if (pairOnBoard) labels.push("페어 보드");
      if (flushDraw || straightDraw) labels.push("드로우가 많아 변동성이 큼");
      return labels.length ? labels.join(", ") : "드로우가 적어 변동성이 낮은 편";
    }

    function hasStraightDraw(ranks) {
      const uniq = [...new Set(ranks)].sort((a,b)=>a-b);
      // A를 1로도 취급
      const withAceLow = uniq.includes(14) ? [1, ...uniq] : [...uniq];
      for (let i = 0; i < withAceLow.length; i++) {
        for (let j = i+1; j < withAceLow.length; j++) {
          if (withAceLow[j] - withAceLow[i] > 4) break;
          if (j - i >= 3) return true; // 4장 이상 연속 가능성
        }
      }
      return false;
    }

    function updateMyHandInfo() {
      const cards = state.myHand.concat(state.board);
      if (cards.length < 5) {
        myRankEl.textContent = "카드 부족";
        bestFiveEl.textContent = "-";
        kickerInfoEl.textContent = "-";
        return;
      }
      let best, bestCards;
      if (cards.length === 7) {
        const res = eval7WithCards(cards);
        best = res.hand;
        bestCards = res.cards;
      } else {
        const res = evalBestOfN(cards);
        best = res.hand;
        bestCards = res.cards;
      }
      myRankEl.textContent = rankName(best);
      renderBestFive(bestCards);
      kickerInfoEl.textContent = kickerText(best);
    }

    function eval7WithCards(cards) {
      let best = null;
      let bestCards = null;
      for (let i = 0; i < 7; i++) for (let j = i+1; j < 7; j++)
      for (let k = j+1; k < 7; k++) for (let l = k+1; l < 7; l++)
      for (let m = l+1; m < 7; m++) {
        const five = [cards[i], cards[j], cards[k], cards[l], cards[m]];
        const hand = eval5(five);
        if (!best || compareHands(hand, best) > 0) {
          best = hand;
          bestCards = five;
        }
      }
      return { hand: best, cards: bestCards };
    }

    function evalBestOfN(cards) {
      // 5~6장에서도 가능한 5장 조합 중 최고 족보를 선택
      let best = null;
      let bestCards = null;
      const n = cards.length;
      for (let i = 0; i < n; i++) for (let j = i+1; j < n; j++)
      for (let k = j+1; k < n; k++) for (let l = k+1; l < n; l++)
      for (let m = l+1; m < n; m++) {
        const five = [cards[i], cards[j], cards[k], cards[l], cards[m]];
        const hand = eval5(five);
        if (!best || compareHands(hand, best) > 0) {
          best = hand;
          bestCards = five;
        }
      }
      return { hand: best, cards: bestCards };
    }

    function renderSelected(container, cards, emptyText) {
      container.innerHTML = "";
      if (cards.length === 0) {
        const span = document.createElement("div");
        span.className = "pill";
        span.textContent = emptyText;
        container.appendChild(span);
        return;
      }
      for (const c of cards) {
        const chip = document.createElement("div");
        chip.className = "chip";
        chip.innerHTML = `<span>${cardHTML(c)}</span><span class="x">×</span>`;
        chip.onclick = () => removeCard(c);
        container.appendChild(chip);
      }
    }

    function removeCard(card) {
      if (state.running) return;
      const i = state.myHand.indexOf(card);
      if (i >= 0) state.myHand.splice(i, 1);
      else {
        const j = state.board.indexOf(card);
        if (j >= 0) state.board.splice(j, 1);
      }
      syncCards();
    }

    function renderBestFive(cards) {
      bestFiveEl.innerHTML = "";
      for (const c of cards) {
        const el = document.createElement("div");
        el.className = "mini-card";
        el.innerHTML = cardHTML(c);
        bestFiveEl.appendChild(el);
      }
    }

    function kickerText(score) {
      const t = score.tiebreak;
      const r = (v) => Object.entries(RANK_VALUE).find(([,val])=>val===v)[0];
      if (score.rank === 8) return `최고 카드: ${r(t[0])}`;
      if (score.rank === 7) return `포카드 ${r(t[0])}, 키커 ${r(t[1])}`;
      if (score.rank === 6) return `트리플 ${r(t[0])} + 페어 ${r(t[1])}`;
      if (score.rank === 5) return `플러시 상위 카드: ${t.map(r).join(", ")}`;
      if (score.rank === 4) return `스트레이트 최고 카드: ${r(t[0])}`;
      if (score.rank === 3) return `트리플 ${r(t[0])}, 키커 ${r(t[1])}/${r(t[2])}`;
      if (score.rank === 2) return `투페어 ${r(t[0])}/${r(t[1])}, 키커 ${r(t[2])}`;
      if (score.rank === 1) return `원페어 ${r(t[0])}, 키커 ${r(t[1])}/${r(t[2])}/${r(t[3])}`;
      return `하이카드 ${t.map(r).join(", ")}`;
    }

    function renderThreatInfo(rankCounts, done) {
      if (!rankCounts || done === 0) {
        threatBox.textContent = "-";
        return;
      }
      const name = (r) => ["하이카드","원페어","투페어","트리플","스트레이트","플러시","풀하우스","포카드","스트레이트 플러시"][r];
      const totalOpp = [...rankCounts.values()].reduce((a,b)=>a+b, 0) || 1;
      const sorted = [...rankCounts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
      threatBox.innerHTML = "";
      if (sorted.length === 0) {
        threatBox.textContent = "현재 조건에서 상대가 내 핸드를 이길 빈도가 매우 낮게 나타남";
        return;
      }
      for (const [r, c] of sorted) {
        const pct = (c / totalOpp) * 100;
        const row = document.createElement("div");
        row.className = "threat-row";
        row.innerHTML = `
          <div>${name(r)}</div>
          <div class="threat-bar"><span style="width:${pct.toFixed(1)}%"></span></div>
          <div>${pct.toFixed(1)}%</div>
        `;
        threatBox.appendChild(row);
      }
    }

    function rankName(score) {
      const names = [
        "하이카드",
        "원페어",
        "투페어",
        "트리플",
        "스트레이트",
        "플러시",
        "풀하우스",
        "포카드",
        "스트레이트 플러시"
      ];
      return names[score.rank] || "-";
    }

    // ===== Monte Carlo 시뮬레이션 =====
    runBtn.onclick = () => {
      if (state.running) return;
      if (!validateInputs()) return;
      state.running = true;
      runBtn.disabled = true;
      resetBtn.disabled = true;

      const totalTrials = Number(trialsEl.value);
      const opponents = Number(opponentsEl.value);
      let wins = 0, ties = 0, losses = 0, done = 0;
      const threatCounts = new Map();
      const baseDeck = makeDeck().filter(c => ![...state.myHand, ...state.board].includes(c));

      const chunkSize = 500; // UI 멈춤 방지

      function step() {
        const start = performance.now();
        for (let t = 0; t < chunkSize && done < totalTrials; t++) {
          const deck = baseDeck.slice();
          shuffleInPlace(deck);

          const oppHands = [];
          for (let p = 0; p < opponents; p++) {
            oppHands.push([deck.pop(), deck.pop()]);
          }

          const board = state.board.slice();
          while (board.length < 5) board.push(deck.pop());

          const my7 = state.myHand.concat(board);
          const myScore = eval7(my7);

          let best = myScore;
          let bestCount = 1;

          for (const opp of oppHands) {
            const oppScore = eval7(opp.concat(board));
            const cmpToMe = compareHands(oppScore, myScore);
            if (cmpToMe > 0) {
              threatCounts.set(oppScore.rank, (threatCounts.get(oppScore.rank) || 0) + 1);
            }
            const cmp = compareHands(oppScore, best);
            if (cmp > 0) {
              best = oppScore;
              bestCount = 1;
            } else if (cmp === 0) {
              bestCount++;
            } else {
              // my/best still higher
            }
          }

          const cmpMyBest = compareHands(myScore, best);
          if (cmpMyBest > 0) {
            wins++;
          } else if (cmpMyBest === 0) {
            if (bestCount === 1) wins++;
            else ties++;
          } else {
            losses++;
          }

          done++;
        }

        const winPct = (wins / done) * 100;
        const tiePct = (ties / done) * 100;
        const losePct = (losses / done) * 100;

        winPctEl.textContent = winPct.toFixed(2) + "%";
        tiePctEl.textContent = tiePct.toFixed(2) + "%";
        losePctEl.textContent = losePct.toFixed(2) + "%";
        updateMyHandInfo();
        renderThreatInfo(threatCounts, done);

        const pct = (done / totalTrials) * 100;
        bar.style.width = pct.toFixed(1) + "%";
        progressText.textContent = `진행률 ${pct.toFixed(1)}% (${done}/${totalTrials})`;

        if (done < totalTrials) {
          if (performance.now() - start < 14) {
            requestAnimationFrame(step);
          } else {
            setTimeout(step, 0);
          }
        } else {
          state.running = false;
          runBtn.disabled = false;
          resetBtn.disabled = false;
          progressText.textContent = `완료 (${totalTrials} trials)`;
        }
      }

      step();
    };

    renderCards();
    syncCards();
    sanityTests();
  </script>
</body>
</html>
